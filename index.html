<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Video Subtitle Editor Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body.dark {
            background-color: #1a202c; /* Equivalent to Tailwind's dark:bg-gray-900 */
            color: #e2e8f0; /* Equivalent to Tailwind's dark:text-gray-200 */
        }
        .timeline-frame-container {
            transition: transform 0.2s, box-shadow 0.3s;
            cursor: pointer;
        }
        .timeline-frame-container:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .subtitle-item-list {
            transition: background-color 0.3s;
        }
        .subtitle-item-list:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        .dark .subtitle-item-list:hover {
            background-color: #4a5568; /* gray-700 */
        }
        video::-webkit-media-controls {
            z-index: 10; /* Lowered to allow custom elements on top if needed */
        }
        .custom-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
        }
        .custom-controls button {
            margin: 0 4px;
        }
        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        #timeline {
            position: relative;
            background-color: #f0f0f0;
        }
        .dark #timeline {
            background-color: #2d3748; /* gray-800 */
        }
        #timelinePlayhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background-color: red;
            cursor: ew-resize;
            z-index: 20;
        }
        #timelineFrames {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden; /* Prevent vertical scrollbar */
            padding-bottom: 10px; /* Space for scrollbar without overlap */
        }
        .subtitle-block-on-timeline {
            position: absolute;
            height: 20px;
            bottom: 5px; /* Position above scrollbar */
            background-color: rgba(79, 70, 229, 0.7); /* indigo-600 with opacity */
            border: 1px solid rgba(67, 56, 202, 1); /* indigo-700 */
            border-radius: 3px;
            z-index: 15;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            font-size: 10px;
            color: white;
            padding: 0 4px;
            line-height: 18px;
            cursor: pointer;
        }
        .dark .subtitle-block-on-timeline {
             background-color: rgba(99, 102, 241, 0.7); /* indigo-500 with opacity for dark mode */
             border: 1px solid rgba(79, 70, 229, 1); /* indigo-600 for dark mode */
        }
        .toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .toast-notification.show {
            opacity: 1;
        }
        #timelineLoader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
        }
        .loader-spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px auto;
        }
        .dark .loader-spinner {
            border: 4px solid #4a5568; /* gray-700 */
            border-top: 4px solid #60a5fa; /* blue-400 */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 font-sans transition-colors duration-300 text-gray-900 dark:text-gray-100">
    <div class="max-w-7xl mx-auto p-6">
        <button id="darkModeToggle" class="dark-mode-toggle py-2 px-4 bg-gray-300 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full hover:bg-gray-400 dark:hover:bg-gray-600 transition">Toggle Dark Mode</button>

        <h1 class="text-3xl font-bold mb-6 text-center text-gray-800 dark:text-gray-200">Advanced Video Subtitle Editor Pro</h1>

        <!-- Video Player -->
        <div class="bg-white dark:bg-gray-800 shadow-xl rounded-lg p-4 mb-6">
            <div class="relative">
                <video id="videoPlayer" class="w-full rounded-md" controls>
                    <track id="subtitleTrack" kind="subtitles" srclang="en" label="English">
                    Your browser does not support the video tag.
                </video>
                <div class="custom-controls">
                    <label for="videoInput" class="cursor-pointer py-2 px-4 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition">
                        Upload Video
                    </label>
                    <input type="file" id="videoInput" accept="video/*" class="hidden">
                    <span id="videoFileName" class="ml-4 text-sm text-gray-600 dark:text-gray-400">No video loaded</span>
                </div>
            </div>
        </div>

        <!-- Subtitle Panel -->
        <div class="bg-white dark:bg-gray-800 shadow-xl rounded-lg p-4 mb-6">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end mb-4">
                <div class="md:col-span-1">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Current Time (Press 'I'/'O' to set start/end)</label>
                    <input type="text" id="currentTimeDisplay" class="w-full border rounded-md p-2 text-center bg-gray-100 dark:bg-gray-700 dark:text-white" readonly value="00:00:00.000">
                </div>
                <div class="md:col-span-2">
                    <label for="subtitleText" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Subtitle Text (Ctrl+Enter to Add/Update)</label>
                    <textarea id="subtitleText" rows="2" class="w-full border rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-white" placeholder="Enter subtitle text..."></textarea>
                </div>
            </div>
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 items-end mb-4">
                <div>
                    <label for="subtitleDuration" class="block text-sm text-gray-700 dark:text-gray-300 mb-1">Duration (s)</label>
                    <input type="number" id="subtitleDuration" min="0.1" step="0.1" value="3" class="w-full border rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-white">
                </div>
                <div>
                    <label for="subtitleFontSize" class="block text-sm text-gray-700 dark:text-gray-300 mb-1">Font Size</label>
                    <select id="subtitleFontSize" class="w-full border rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-white">
                        <option value="16px">16px</option>
                        <option value="20px">20px</option>
                        <option value="24px" selected>24px</option>
                        <option value="28px">28px</option>
                        <option value="32px">32px</option>
                    </select>
                </div>
                <div>
                    <label for="subtitleColor" class="block text-sm text-gray-700 dark:text-gray-300 mb-1">Text Color</label>
                    <input type="color" id="subtitleColor" value="#FFFFFF" class="w-full h-10 border rounded-md dark:bg-gray-700 p-1">
                </div>
                <div>
                    <label for="subtitleBgColor" class="block text-sm text-gray-700 dark:text-gray-300 mb-1">BG Color</label>
                    <input type="color" id="subtitleBgColor" value="#000000" class="w-full h-10 border rounded-md dark:bg-gray-700 p-1">
                </div>
            </div>
            <div class="flex flex-wrap items-center space-x-0 sm:space-x-2 space-y-2 sm:space-y-0">
                <button id="addSubtitleBtn" class="w-full sm:w-auto py-2 px-4 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition">Add Subtitle</button>
                <button id="cancelEditBtn" class="w-full sm:w-auto py-2 px-4 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition hidden">Cancel Edit</button>
                <button id="downloadVTTBtn" class="w-full sm:w-auto py-2 px-4 bg-green-600 text-white rounded-md hover:bg-green-700 transition">Download VTT</button>
                <button id="clearStorageBtn" class="w-full sm:w-auto py-2 px-4 bg-red-500 text-white rounded-md hover:bg-red-600 transition">Clear Saved Subtitles</button>
            </div>
            <div id="subtitleList" class="mt-4 max-h-60 overflow-y-auto border rounded-md p-2 bg-gray-50 dark:bg-gray-700/50">
                <!-- Subtitles will be dynamically added here -->
            </div>
        </div>

        <!-- Timeline -->
        <div class="bg-white dark:bg-gray-800 shadow-xl rounded-lg p-4 relative">
            <h3 class="text-lg font-semibold mb-2 text-gray-700 dark:text-gray-300">Timeline</h3>
            <div id="timelineLoader" class="hidden">
                <div class="loader-spinner"></div>
                Generating timeline frames...
            </div>
            <div id="timeline" class="h-32 overflow-hidden whitespace-nowrap relative border border-gray-300 dark:border-gray-700 rounded">
                <div id="timelineFrames" class="h-full">
                    <!-- Frames will be dynamically added -->
                </div>
                <div id="timelineSubtitleLayer" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                    <!-- Subtitle blocks will be rendered here -->
                </div>
                <div id="timelinePlayhead"></div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast-notification"></div>

    <script>
        class Utils {
            static formatTime(timeInSeconds) {
                const hours = Math.floor(timeInSeconds / 3600);
                const minutes = Math.floor((timeInSeconds % 3600) / 60);
                const seconds = Math.floor(timeInSeconds % 60);
                const milliseconds = Math.floor((timeInSeconds - Math.floor(timeInSeconds)) * 1000);
                if (hours > 0) {
                    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
                }
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
            }

            static parseTime(timeStr) {
                if (!timeStr) return 0;
                const parts = timeStr.split(':');
                let seconds = 0;
                if (parts.length === 3) { // HH:MM:SS.mmm
                    seconds += parseInt(parts[0]) * 3600;
                    seconds += parseInt(parts[1]) * 60;
                    seconds += parseFloat(parts[2]);
                } else if (parts.length === 2) { // MM:SS.mmm
                    seconds += parseInt(parts[0]) * 60;
                    seconds += parseFloat(parts[1]);
                }
                return seconds;
            }

            static generateSafeCssClass(str) {
                return 'substyle_' + str.replace(/[^a-zA-Z0-9]/g, '_');
            }
        }

        class UIManager {
            constructor() {
                this.darkModeToggle = document.getElementById('darkModeToggle');
                this.currentTimeDisplay = document.getElementById('currentTimeDisplay');
                this.subtitleText = document.getElementById('subtitleText');
                this.subtitleDuration = document.getElementById('subtitleDuration');
                this.subtitleFontSize = document.getElementById('subtitleFontSize');
                this.subtitleColor = document.getElementById('subtitleColor');
                this.subtitleBgColor = document.getElementById('subtitleBgColor');
                this.addSubtitleBtn = document.getElementById('addSubtitleBtn');
                this.cancelEditBtn = document.getElementById('cancelEditBtn');
                this.subtitleList = document.getElementById('subtitleList');
                this.toast = document.getElementById('toast');
                this.videoFileNameDisplay = document.getElementById('videoFileName');

                this._initDarkMode();
            }

            _initDarkMode() {
                this.darkModeToggle.addEventListener('click', () => {
                    document.body.classList.toggle('dark');
                    localStorage.setItem('darkMode', document.body.classList.contains('dark'));
                });
                if (localStorage.getItem('darkMode') === 'true') {
                    document.body.classList.add('dark');
                }
            }

            updateCurrentTime(time) {
                this.currentTimeDisplay.value = Utils.formatTime(time);
            }
            
            setVideoFileName(name) {
                this.videoFileNameDisplay.textContent = name || "No video loaded";
            }

            getSubtitleInput() {
                return {
                    text: this.subtitleText.value.trim(),
                    duration: parseFloat(this.subtitleDuration.value) || 3,
                    fontSize: this.subtitleFontSize.value,
                    color: this.subtitleColor.value,
                    bgColor: this.subtitleBgColor.value,
                };
            }

            populateSubtitleInput(subtitle) {
                this.subtitleText.value = subtitle.text;
                this.subtitleDuration.value = (Utils.parseTime(subtitle.endTime) - Utils.parseTime(subtitle.startTime)).toFixed(1);
                this.subtitleFontSize.value = subtitle.fontSize;
                this.subtitleColor.value = subtitle.color;
                this.subtitleBgColor.value = subtitle.bgColor;
            }

            clearSubtitleInput() {
                this.subtitleText.value = '';
                // Optionally reset other fields to defaults
                // this.subtitleDuration.value = 3;
                // this.subtitleFontSize.value = "24px";
                // this.subtitleColor.value = "#FFFFFF";
                // this.subtitleBgColor.value = "#000000";
            }

            renderSubtitleList(subtitles, editCb, deleteCb, jumpToCb) {
                this.subtitleList.innerHTML = '';
                if (subtitles.length === 0) {
                    this.subtitleList.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">No subtitles yet.</p>';
                    return;
                }
                subtitles.forEach((sub, index) => {
                    const div = document.createElement('div');
                    div.className = 'subtitle-item-list p-2 rounded-md flex justify-between items-center mb-1 border-b border-gray-200 dark:border-gray-700';
                    div.innerHTML = `
                        <div class="flex-grow cursor-pointer" title="Click to jump to subtitle">
                            <span class="font-mono text-sm">${sub.startTime} --> ${sub.endTime}</span>
                            <p class="text-sm truncate" style="color:${sub.color}; background-color:${sub.bgColor}; padding: 2px 4px; display: inline-block; border-radius: 3px;">${sub.text}</p>
                        </div>
                        <div class="flex-shrink-0">
                            <button data-index="${index}" class="edit-btn text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300 mr-2 text-sm">Edit</button>
                            <button data-index="${index}" class="delete-btn text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 text-sm">Delete</button>
                        </div>
                    `;
                    div.querySelector('.flex-grow').addEventListener('click', () => jumpToCb(index));
                    div.querySelector('.edit-btn').addEventListener('click', () => editCb(index));
                    div.querySelector('.delete-btn').addEventListener('click', () => deleteCb(index));
                    this.subtitleList.appendChild(div);
                });
            }

            setEditingState(isEditing) {
                if (isEditing) {
                    this.addSubtitleBtn.textContent = 'Update Subtitle';
                    this.addSubtitleBtn.classList.replace('bg-indigo-600', 'bg-yellow-500');
                    this.addSubtitleBtn.classList.replace('hover:bg-indigo-700', 'hover:bg-yellow-600');
                    this.cancelEditBtn.classList.remove('hidden');
                } else {
                    this.addSubtitleBtn.textContent = 'Add Subtitle';
                    this.addSubtitleBtn.classList.replace('bg-yellow-500', 'bg-indigo-600');
                    this.addSubtitleBtn.classList.replace('hover:bg-yellow-600', 'hover:bg-indigo-700');
                    this.cancelEditBtn.classList.add('hidden');
                    this.clearSubtitleInput();
                }
            }

            showToast(message, duration = 3000) {
                this.toast.textContent = message;
                this.toast.classList.add('show');
                setTimeout(() => {
                    this.toast.classList.remove('show');
                }, duration);
            }
        }

        class VideoManager {
            constructor(uiManager, timeUpdateCallback, loadedMetadataCallback) {
                this.uiManager = uiManager;
                this.video = document.getElementById('videoPlayer');
                this.videoInput = document.getElementById('videoInput');
                this.subtitleTrack = document.getElementById('subtitleTrack');
                this.timeUpdateCallback = timeUpdateCallback;
                this.loadedMetadataCallback = loadedMetadataCallback;
                this.currentVideoName = null;
                this.blobURL = null;

                this.videoInput.addEventListener('change', this._handleVideoLoad.bind(this));
                this.video.addEventListener('timeupdate', () => this.timeUpdateCallback(this.video.currentTime));
                this.video.addEventListener('loadedmetadata', () => {
                    this.uiManager.updateCurrentTime(0); // Reset time display
                    if (this.loadedMetadataCallback) this.loadedMetadataCallback(this.video.duration);
                });
                 this.video.addEventListener('play', () => { /* Can add logic */ });
                 this.video.addEventListener('pause', () => { /* Can add logic */ });
            }

            _handleVideoLoad(event) {
                const file = event.target.files[0];
                if (file) {
                    if (this.blobURL) URL.revokeObjectURL(this.blobURL);
                    this.blobURL = URL.createObjectURL(file);
                    this.video.src = this.blobURL;
                    this.currentVideoName = file.name;
                    this.uiManager.setVideoFileName(this.currentVideoName);
                    this.video.load(); // Important for track to re-evaluate
                    if (this.loadedMetadataCallback) this.loadedMetadataCallback(this.video.duration, true); // true indicates new video
                }
            }

            get currentTime() { return this.video.currentTime; }
            set currentTime(time) { this.video.currentTime = time; }
            get duration() { return this.video.duration; }
            get paused() { return this.video.paused; }

            play() { this.video.play(); }
            pause() { this.video.pause(); }

            updateSubtitleTrackVTT(vttContent) {
                const blob = new Blob([vttContent], { type: 'text/vtt' });
                const url = URL.createObjectURL(blob);
                
                if (this.subtitleTrack.dataset.oldSrc) {
                    URL.revokeObjectURL(this.subtitleTrack.dataset.oldSrc);
                }
                this.subtitleTrack.src = url;
                this.subtitleTrack.dataset.oldSrc = url;

                // Force refresh of text tracks
                if (this.video.textTracks.length > 0) {
                    this.video.textTracks[0].mode = 'hidden'; // Must be 'hidden' before 'showing' to force re-render
                    this.video.textTracks[0].mode = 'showing';
                }
            }

            cleanup() {
                if (this.blobURL) URL.revokeObjectURL(this.blobURL);
                if (this.subtitleTrack.dataset.oldSrc) URL.revokeObjectURL(this.subtitleTrack.dataset.oldSrc);
            }
        }

        class SubtitleManager {
            constructor(videoManager, uiManager, timelineManager) {
                this.videoManager = videoManager;
                this.uiManager = uiManager;
                this.timelineManager = timelineManager; // To update timeline visuals
                this.subtitles = [];
                this.editingIndex = null; // null or index of subtitle being edited
                this.styleMap = new Map(); // To map style combinations to class names

                this.uiManager.addSubtitleBtn.addEventListener('click', this.handleAddOrUpdateSubtitle.bind(this));
                this.uiManager.cancelEditBtn.addEventListener('click', this.cancelEdit.bind(this));
                document.getElementById('downloadVTTBtn').addEventListener('click', this.downloadVTT.bind(this));
                document.getElementById('clearStorageBtn').addEventListener('click', this.clearLocalStorageSubtitles.bind(this));
            }

            setSubtitles(newSubtitles) {
                this.subtitles = newSubtitles;
                this.sortSubtitles();
                this.refreshDisplay();
            }

            handleAddOrUpdateSubtitle() {
                const input = this.uiManager.getSubtitleInput();
                if (!input.text) {
                    this.uiManager.showToast('Please enter subtitle text.');
                    return;
                }

                const startTime = this.videoManager.currentTime;
                let endTimeSeconds = startTime + input.duration;

                // Prevent overlap with next subtitle if not editing that specific one
                const nextSub = this.subtitles.find((s, idx) => 
                    Utils.parseTime(s.startTime) > startTime && idx !== this.editingIndex
                );
                if (nextSub) {
                    endTimeSeconds = Math.min(endTimeSeconds, Utils.parseTime(nextSub.startTime) - 0.001);
                }
                endTimeSeconds = Math.max(endTimeSeconds, startTime + 0.1); // Minimum duration

                const newSubtitle = {
                    startTime: Utils.formatTime(startTime),
                    endTime: Utils.formatTime(endTimeSeconds),
                    text: input.text,
                    fontSize: input.fontSize,
                    color: input.color,
                    bgColor: input.bgColor,
                };

                if (this.editingIndex !== null) {
                    this.subtitles[this.editingIndex] = newSubtitle;
                    this.uiManager.showToast('Subtitle updated!');
                } else {
                    this.subtitles.push(newSubtitle);
                    this.uiManager.showToast('Subtitle added!');
                }
                
                this.sortSubtitles();
                this.cancelEdit(); // Resets UI and editingIndex
                this.refreshDisplay();
                this.saveToLocalStorage();
            }
            
            sortSubtitles() {
                this.subtitles.sort((a, b) => Utils.parseTime(a.startTime) - Utils.parseTime(b.startTime));
            }

            editSubtitle(index) {
                this.editingIndex = index;
                const sub = this.subtitles[index];
                this.uiManager.populateSubtitleInput(sub);
                this.uiManager.setEditingState(true);
                this.videoManager.currentTime = Utils.parseTime(sub.startTime);
                this.uiManager.subtitleText.focus();
            }

            deleteSubtitle(index) {
                if (confirm('Are you sure you want to delete this subtitle?')) {
                    this.subtitles.splice(index, 1);
                    if (this.editingIndex === index) this.cancelEdit();
                    else if (this.editingIndex > index) this.editingIndex--; // Adjust if deleting before current edit
                    
                    this.refreshDisplay();
                    this.saveToLocalStorage();
                    this.uiManager.showToast('Subtitle deleted.');
                }
            }
            
            jumpToSubtitle(index) {
                if (this.subtitles[index]) {
                    this.videoManager.currentTime = Utils.parseTime(this.subtitles[index].startTime);
                    this.videoManager.play();
                }
            }

            cancelEdit() {
                this.editingIndex = null;
                this.uiManager.setEditingState(false);
            }

            refreshDisplay() {
                this.uiManager.renderSubtitleList(
                    this.subtitles,
                    this.editSubtitle.bind(this),
                    this.deleteSubtitle.bind(this),
                    this.jumpToSubtitle.bind(this)
                );
                this.generateAndApplyVTT();
                if (this.timelineManager) { // Update timeline if it exists
                    this.timelineManager.renderSubtitlesOnTimeline(this.subtitles);
                }
            }

            generateAndApplyVTT() {
                this.styleMap.clear();
                let styleBlock = 'STYLE\n';
                let cueIdCounter = 0;

                const vttCues = this.subtitles.map((sub, index) => {
                    const styleKey = `${sub.fontSize}_${sub.color}_${sub.bgColor}`;
                    let className = this.styleMap.get(styleKey);
                    if (!className) {
                        className = Utils.generateSafeCssClass(styleKey);
                        this.styleMap.set(styleKey, className);
                        styleBlock += `::cue(.${className}) {\n`;
                        styleBlock += `  font-size: ${sub.fontSize};\n`;
                        styleBlock += `  color: ${sub.color};\n`;
                        styleBlock += `  background-color: ${sub.bgColor === '#000000' && sub.text.length > 0 ? 'rgba(0,0,0,0.6)' : sub.bgColor };\n`; // Slight transparency for black default
                        styleBlock += `}\n`;
                    }
                    cueIdCounter++;
                    return `${cueIdCounter}\n${sub.startTime} --> ${sub.endTime}\n<c.${className}>${sub.text}</c>\n`;
                }).join('\n');

                const vttContent = `WEBVTT\n\n${styleBlock}\n${vttCues}`;
                this.videoManager.updateSubtitleTrackVTT(vttContent);
            }

            downloadVTT() {
                if (this.subtitles.length === 0) {
                    this.uiManager.showToast('No subtitles to download.');
                    return;
                }
                // Ensure VTT is up-to-date before download
                this.generateAndApplyVTT(); // This updates the VTT content internally
                
                // Re-generate for download to ensure it's current
                this.styleMap.clear();
                let styleBlock = 'STYLE\n';
                let cueIdCounter = 0;
                const vttCues = this.subtitles.map((sub, index) => {
                    const styleKey = `${sub.fontSize}_${sub.color}_${sub.bgColor}`;
                    let className = this.styleMap.get(styleKey);
                    if (!className) {
                        className = Utils.generateSafeCssClass(styleKey);
                        this.styleMap.set(styleKey, className);
                        styleBlock += `::cue(.${className}) {\n`;
                        styleBlock += `  font-size: ${sub.fontSize};\n`;
                        styleBlock += `  color: ${sub.color};\n`;
                        styleBlock += `  background-color: ${sub.bgColor === '#000000' && sub.text.length > 0 ? 'rgba(0,0,0,0.6)' : sub.bgColor };\n`;
                        styleBlock += `}\n`;
                    }
                    cueIdCounter++;
                    return `${cueIdCounter}\n${sub.startTime} --> ${sub.endTime}\n<c.${className}>${sub.text}</c>\n`;
                }).join('\n');
                const vttContent = `WEBVTT\n\n${styleBlock}\n${vttCues}`;

                const blob = new Blob([vttContent], { type: 'text/vtt' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.videoManager.currentVideoName || 'subtitles'}.vtt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.uiManager.showToast('VTT file downloaded.');
            }
            
            getLocalStorageKey() {
                return this.videoManager.currentVideoName ? `subtitles_${this.videoManager.currentVideoName}` : null;
            }

            saveToLocalStorage() {
                const key = this.getLocalStorageKey();
                if (key) {
                    localStorage.setItem(key, JSON.stringify(this.subtitles));
                    console.log('Subtitles saved to local storage for', this.videoManager.currentVideoName);
                }
            }

            loadFromLocalStorage() {
                const key = this.getLocalStorageKey();
                if (key) {
                    const savedSubtitles = localStorage.getItem(key);
                    if (savedSubtitles) {
                        this.subtitles = JSON.parse(savedSubtitles);
                        this.sortSubtitles(); // Ensure sorted
                        this.refreshDisplay();
                        this.uiManager.showToast(`Subtitles loaded for ${this.videoManager.currentVideoName}`);
                        return true;
                    }
                }
                this.subtitles = []; // Reset if nothing loaded
                this.refreshDisplay();
                return false;
            }
            
            clearLocalStorageSubtitles() {
                const key = this.getLocalStorageKey();
                if (key) {
                    localStorage.removeItem(key);
                    this.subtitles = [];
                    this.refreshDisplay();
                    this.uiManager.showToast(`Cleared saved subtitles for ${this.videoManager.currentVideoName}.`);
                } else {
                    this.uiManager.showToast('No video loaded to clear subtitles for.');
                }
            }
        }

        class TimelineManager {
            constructor(videoManager, uiManager) {
                this.videoManager = videoManager;
                this.uiManager = uiManager;
                this.timeline = document.getElementById('timeline');
                this.timelineFramesContainer = document.getElementById('timelineFrames');
                this.timelinePlayhead = document.getElementById('timelinePlayhead');
                this.timelineSubtitleLayer = document.getElementById('timelineSubtitleLayer');
                this.timelineLoader = document.getElementById('timelineLoader');

                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.frameWidth = 120; // Increased width for better preview
                this.frameHeight = 72; // Maintain 16:9 aspect ratio
                this.framesPerSegment = 10; // How many frames to draw per second of video (adjust for performance/detail)
                this.isDraggingPlayhead = false;

                this.timelinePlayhead.addEventListener('mousedown', this._startDragPlayhead.bind(this));
                document.addEventListener('mousemove', this._dragPlayhead.bind(this));
                document.addEventListener('mouseup', this._stopDragPlayhead.bind(this));
                this.timeline.addEventListener('click', this._clickTimeline.bind(this));
            }
            
            _showLoader(show) {
                this.timelineLoader.classList.toggle('hidden', !show);
            }

            async generateTimelineFrames() {
                if (!this.videoManager.duration || this.videoManager.duration === Infinity) {
                     this.timelineFramesContainer.innerHTML = '<p class="p-4 text-center text-gray-500 dark:text-gray-400">Load a video to generate timeline.</p>';
                    return;
                }
                
                this._showLoader(true);
                this.timelineFramesContainer.innerHTML = ''; // Clear previous frames
                const totalDuration = this.videoManager.duration;
                const numFrames = Math.ceil(totalDuration * (this.framesPerSegment / 10)); // framesPerSegment is effectively frames per 10s
                const timeInterval = totalDuration / numFrames;

                this.canvas.width = this.frameWidth;
                this.canvas.height = this.frameHeight;

                const originalTime = this.videoManager.currentTime;
                const wasPaused = this.videoManager.paused;
                if(!wasPaused) this.videoManager.pause();

                for (let i = 0; i < numFrames; i++) {
                    const time = i * timeInterval;
                    try {
                        const frameDataUrl = await this._captureFrame(time);
                        this._addFrameToTimeline(frameDataUrl, time);
                    } catch (error) {
                        console.error(`Error capturing frame at ${time}s:`, error);
                        // Add a placeholder for failed frames
                        this._addFrameToTimeline(null, time, true); 
                    }
                }
                
                this.videoManager.currentTime = originalTime; // Restore original time
                if(!wasPaused) this.videoManager.play();
                this._showLoader(false);
                this.updatePlayheadPosition(); // Initial position
            }
            
            _captureFrame(time) {
                return new Promise((resolve, reject) => {
                    this.videoManager.video.currentTime = time;
                    const onSeeked = () => {
                        this.videoManager.video.removeEventListener('seeked', onSeeked);
                        this.videoManager.video.removeEventListener('error', onError);
                        this.ctx.drawImage(this.videoManager.video, 0, 0, this.canvas.width, this.canvas.height);
                        resolve(this.canvas.toDataURL('image/jpeg', 0.7)); // Use JPEG for smaller size
                    };
                    const onError = (e) => {
                        this.videoManager.video.removeEventListener('seeked', onSeeked);
                        this.videoManager.video.removeEventListener('error', onError);
                        reject(new Error('Video seeking error or decoding error.'));
                    };
                    this.videoManager.video.addEventListener('seeked', onSeeked, { once: true });
                    this.videoManager.video.addEventListener('error', onError, { once: true });
                });
            }

            _addFrameToTimeline(imageDataUrl, time, isError = false) {
                const frameDiv = document.createElement('div');
                frameDiv.className = 'timeline-frame-container inline-block relative flex-shrink-0';
                frameDiv.style.width = `${this.frameWidth}px`;
                frameDiv.style.height = `${this.frameHeight}px`;
                frameDiv.dataset.time = time;

                if (isError || !imageDataUrl) {
                    frameDiv.innerHTML = `<div class="w-full h-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center text-xs text-red-500">Error</div>`;
                } else {
                    const img = document.createElement('img');
                    img.src = imageDataUrl;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    frameDiv.appendChild(img);
                }
                
                const timeLabel = document.createElement('span');
                timeLabel.className = 'absolute bottom-0 left-0 bg-black bg-opacity-50 text-white text-xs px-1 rounded-tr-md';
                timeLabel.textContent = Utils.formatTime(time).split('.')[0]; // Show only HH:MM:SS
                frameDiv.appendChild(timeLabel);

                frameDiv.addEventListener('click', () => {
                    this.videoManager.currentTime = parseFloat(frameDiv.dataset.time);
                });
                this.timelineFramesContainer.appendChild(frameDiv);
            }
            
            updatePlayheadPosition() {
                if (!this.videoManager.duration || this.videoManager.duration === Infinity) return;
                const progress = (this.videoManager.currentTime / this.videoManager.duration);
                // The playhead is relative to the timelineFramesContainer scroll width
                const scrollWidth = this.timelineFramesContainer.scrollWidth;
                const newLeft = progress * scrollWidth;
                
                this.timelinePlayhead.style.left = `${newLeft}px`;

                // Auto-scroll timeline container to keep playhead in view
                const containerRect = this.timelineFramesContainer.getBoundingClientRect();
                const playheadRect = this.timelinePlayhead.getBoundingClientRect();
                
                // Calculate playhead position relative to the visible part of timelineFramesContainer
                const playheadVisibleLeft = newLeft - this.timelineFramesContainer.scrollLeft;

                if (playheadVisibleLeft < 0) { // Playhead is to the left of viewport
                    this.timelineFramesContainer.scrollLeft = newLeft;
                } else if (playheadVisibleLeft > containerRect.width - this.timelinePlayhead.offsetWidth) { // Playhead is to the right
                    this.timelineFramesContainer.scrollLeft = newLeft - containerRect.width + this.timelinePlayhead.offsetWidth;
                }
            }

             _startDragPlayhead(event) {
                this.isDraggingPlayhead = true;
                this.timelinePlayhead.style.transition = 'none'; // Disable smooth transition during drag
                this._updateVideoTimeFromPlayhead(event.clientX);
            }

            _dragPlayhead(event) {
                if (this.isDraggingPlayhead) {
                    this._updateVideoTimeFromPlayhead(event.clientX);
                }
            }

            _stopDragPlayhead() {
                if (this.isDraggingPlayhead) {
                    this.isDraggingPlayhead = false;
                    this.timelinePlayhead.style.transition = ''; // Re-enable transition
                }
            }

            _clickTimeline(event) {
                 // Only react if click is directly on timeline bg, not on frames or playhead
                if (event.target === this.timeline || event.target === this.timelineFramesContainer || event.target === this.timelineSubtitleLayer) {
                    this._updateVideoTimeFromPlayhead(event.clientX);
                }
            }

            _updateVideoTimeFromPlayhead(clientX) {
                if (!this.videoManager.duration || this.videoManager.duration === Infinity) return;
                const timelineRect = this.timelineFramesContainer.getBoundingClientRect();
                let newLeft = clientX - timelineRect.left + this.timelineFramesContainer.scrollLeft;
                
                // Clamp within bounds
                newLeft = Math.max(0, Math.min(newLeft, this.timelineFramesContainer.scrollWidth));
                
                const progress = newLeft / this.timelineFramesContainer.scrollWidth;
                this.videoManager.currentTime = progress * this.videoManager.duration;
                // The timeupdate event on video will call updatePlayheadPosition
            }

            renderSubtitlesOnTimeline(subtitles) {
                this.timelineSubtitleLayer.innerHTML = ''; // Clear old subtitle blocks
                if (!this.videoManager.duration || this.videoManager.duration === Infinity) return;

                const totalTimelineWidth = this.timelineFramesContainer.scrollWidth;

                subtitles.forEach((sub, index) => {
                    const startTime = Utils.parseTime(sub.startTime);
                    const endTime = Utils.parseTime(sub.endTime);

                    const startPercent = startTime / this.videoManager.duration;
                    const endPercent = endTime / this.videoManager.duration;

                    const left = startPercent * totalTimelineWidth;
                    const width = (endPercent - startPercent) * totalTimelineWidth;

                    if (width <=0) return; // Skip if zero or negative width

                    const subBlock = document.createElement('div');
                    subBlock.className = 'subtitle-block-on-timeline';
                    subBlock.style.left = `${left}px`;
                    subBlock.style.width = `${Math.max(width, 2)}px`; // Min width of 2px
                    subBlock.textContent = sub.text;
                    subBlock.title = `${sub.startTime} -> ${sub.endTime}: ${sub.text}`;
                    subBlock.dataset.index = index;

                    subBlock.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent timeline click
                        // Find the app instance or pass a callback
                        window.app.subtitleManager.jumpToSubtitle(parseInt(subBlock.dataset.index));
                    });

                    this.timelineSubtitleLayer.appendChild(subBlock);
                });
            }
        }
        
        class App {
            constructor() {
                this.uiManager = new UIManager();
                this.videoManager = new VideoManager(
                    this.uiManager,
                    this.handleTimeUpdate.bind(this),
                    this.handleVideoLoaded.bind(this)
                );
                this.timelineManager = new TimelineManager(this.videoManager, this.uiManager);
                this.subtitleManager = new SubtitleManager(this.videoManager, this.uiManager, this.timelineManager);

                this.initKeyboardShortcuts();
                window.addEventListener('beforeunload', this.cleanup.bind(this));

                // Expose app to window for easier debugging if needed
                window.app = this; 
            }

            handleTimeUpdate(currentTime) {
                this.uiManager.updateCurrentTime(currentTime);
                this.timelineManager.updatePlayheadPosition();
            }

            async handleVideoLoaded(duration, isNewVideo = false) {
                if (isNewVideo) {
                    this.subtitleManager.subtitles = []; // Clear old subtitles for new video
                    if (!this.subtitleManager.loadFromLocalStorage()) {
                        // If nothing loaded from storage, refresh with empty list
                        this.subtitleManager.refreshDisplay(); 
                    }
                    // If video has valid duration, generate timeline
                    if(duration && duration !== Infinity) {
                        await this.timelineManager.generateTimelineFrames();
                    } else {
                         this.timelineManager.timelineFramesContainer.innerHTML = '<p class="p-4 text-center text-gray-500 dark:text-gray-400">Video metadata not fully loaded or video has no duration.</p>';
                    }
                    // Render subtitles on timeline after frames are generated and storage loaded
                    this.timelineManager.renderSubtitlesOnTimeline(this.subtitleManager.subtitles);
                }
                 // Ensure playhead is updated even if not a new video (e.g. after frame gen seek)
                this.timelineManager.updatePlayheadPosition();
            }

            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    const activeEl = document.activeElement;
                    const isInputFocused = activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT';

                    if (e.code === 'Space' && !isInputFocused) {
                        e.preventDefault();
                        if (this.videoManager.paused) this.videoManager.play();
                        else this.videoManager.pause();
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                         e.preventDefault();
                         this.subtitleManager.handleAddOrUpdateSubtitle();
                    }

                    if (activeEl === this.uiManager.subtitleText) {
                        if (e.key.toUpperCase() === 'I' && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
                            e.preventDefault();
                            const currentSubTime = Utils.parseTime(this.uiManager.currentTimeDisplay.value);
                            // This doesn't directly set a field, but user uses this info.
                            // Future: Could have "set start" and "set end" buttons tied to this.
                            this.uiManager.showToast(`Start time marker: ${Utils.formatTime(currentSubTime)} (current time)`);
                        }
                        if (e.key.toUpperCase() === 'O' && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
                            e.preventDefault();
                            const currentSubTime = Utils.parseTime(this.uiManager.currentTimeDisplay.value);
                            const startTimeText = this.subtitleManager.editingIndex !== null ? 
                                this.subtitleManager.subtitles[this.subtitleManager.editingIndex].startTime :
                                this.uiManager.currentTimeDisplay.value; // Or some other logic for new subs
                            
                            const startTime = Utils.parseTime(startTimeText);
                            let duration = currentSubTime - startTime;
                            if (duration < 0.1) duration = 0.1;
                            this.uiManager.subtitleDuration.value = duration.toFixed(1);
                            this.uiManager.showToast(`End time set. Duration: ${duration.toFixed(1)}s`);
                        }
                    }
                    
                    if (!isInputFocused) {
                        let seekAmount = 0;
                        if (e.key === 'ArrowLeft')  seekAmount = e.shiftKey ? -5 : -1;
                        if (e.key === 'ArrowRight') seekAmount = e.shiftKey ? 5 : 1;

                        if (seekAmount !== 0) {
                            e.preventDefault();
                            this.videoManager.currentTime = Math.max(0, this.videoManager.currentTime + seekAmount);
                        }

                        if ((e.ctrlKey || e.metaKey) && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                            e.preventDefault();
                            const currentTime = this.videoManager.currentTime;
                            let targetSubTime = -1;
                            if (e.key === 'ArrowLeft') { // Prev subtitle
                                const prevSubs = this.subtitleManager.subtitles
                                    .filter(s => Utils.parseTime(s.startTime) < currentTime - 0.1) // -0.1 to jump if already on one
                                    .sort((a,b) => Utils.parseTime(b.startTime) - Utils.parseTime(a.startTime));
                                if (prevSubs.length > 0) targetSubTime = Utils.parseTime(prevSubs[0].startTime);
                                else if (this.subtitleManager.subtitles.length > 0) targetSubTime = Utils.parseTime(this.subtitleManager.subtitles[0].startTime); // jump to first if no prev
                            } else { // Next subtitle
                                const nextSubs = this.subtitleManager.subtitles
                                    .filter(s => Utils.parseTime(s.startTime) > currentTime + 0.1)
                                    .sort((a,b) => Utils.parseTime(a.startTime) - Utils.parseTime(b.startTime));
                                if (nextSubs.length > 0) targetSubTime = Utils.parseTime(nextSubs[0].startTime);
                            }
                            if (targetSubTime !== -1) this.videoManager.currentTime = targetSubTime;
                        }
                    }
                });
            }

            cleanup() {
                this.videoManager.cleanup();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new App();
        });
    </script>
</body>
</html>